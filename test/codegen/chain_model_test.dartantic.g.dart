// dart format width=80
// GENERATED BY DARTANTIC

part of 'chain_model_test.dart';

// **************************************************************************
// ModelGenerator
// **************************************************************************

const DttModelMeta _dtt_Address_fieldMeta = DttModelMeta(
  fields: {
    'street': DttFieldMeta(
      type: 'String',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'city': DttFieldMeta(
      type: 'String',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'country': DttFieldMeta(
      type: 'String',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'postalCode': DttFieldMeta(
      type: 'String?',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
  },
);

mixin _$AddressMixin {
  static Map<String, dynamic> dttCreate({
    required String street,
    required String city,
    required String country,
    String? postalCode,
  }) {
    final values = <String, dynamic>{
      'street': street,
      'city': city,
      'country': country,
      'postalCode': postalCode,
    };
    final processedValues = dttPreprocess(values);
    dttValidate(processedValues);
    return dttPostprocess(processedValues);
  }

  static Map<String, dynamic> dttPreprocess(Map<String, dynamic> values) {
    // Preprocessing step - modify values before validation
    values['street'] = Address._dttpreprocess_street(values['street']);
    return values;
  }

  static void dttValidateField_street(
    dynamic value,
    Map<String, dynamic> values,
  ) {
    if (value == null) {
      throw DttValidationError('street', 'street is required');
    }
    if (value != null && value.length < 5) {
      throw DttValidationError(
        'street',
        'street must be at least 5 characters',
      );
    }
  }

  static void dttValidateField_city(
    dynamic value,
    Map<String, dynamic> values,
  ) {
    if (value == null) {
      throw DttValidationError('city', 'city is required');
    }
    if (value != null && value.length < 2) {
      throw DttValidationError('city', 'city must be at least 2 characters');
    }
  }

  static void dttValidateField_country(
    dynamic value,
    Map<String, dynamic> values,
  ) {
    if (value == null) {
      throw DttValidationError('country', 'country is required');
    }
    if (value != null && value.length < 2) {
      throw DttValidationError(
        'country',
        'country must be at least 2 characters',
      );
    }
  }

  static void dttValidateField_postalCode(
    dynamic value,
    Map<String, dynamic> values,
  ) {
    if (value != null && !Address._dttvalidate_postalCode(value)) {
      throw DttValidationError(
        'postalCode',
        'postalCode failed custom validation',
      );
    }
  }

  static void dttValidate(Map<String, dynamic> values) {
    if (values['street'] != null)
      dttValidateField_street(values['street'], values);
    if (values['city'] != null) dttValidateField_city(values['city'], values);
    if (values['country'] != null)
      dttValidateField_country(values['country'], values);
    if (values['postalCode'] != null)
      dttValidateField_postalCode(values['postalCode'], values);
  }

  static Map<String, dynamic> dttPostprocess(Map<String, dynamic> values) {
    // Postprocessing step - modify values after validation
    // No postprocessing methods found
    return values;
  }

  static Map<String, dynamic> dttFromMap(Map<String, dynamic> map) {
    // Process and validate map data (including nested models)
    final processedMap = <String, dynamic>{
      'street': map['street'],
      'city': map['city'],
      'country': map['country'],
      'postalCode': map['postalCode'],
    };
    // Apply preprocessing, validation, and postprocessing to the processed map
    final preprocessed = dttPreprocess(processedMap);
    dttValidate(preprocessed);
    return dttPostprocess(preprocessed);
  }

  static Map<String, dynamic> dttToMap(Address obj) {
    // Convert object instance to a map
    return {
      'street': obj.street,
      'city': obj.city,
      'country': obj.country,
      'postalCode': obj.postalCode,
    };
  }
}

const DttModelMeta _dtt_ContactInfo_fieldMeta = DttModelMeta(
  fields: {
    'email': DttFieldMeta(
      type: 'String',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'phone': DttFieldMeta(
      type: 'String?',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'address': DttFieldMeta(
      type: 'Address',
      isFinal: true,
      isLate: false,
      subModel: 'Address',
    ),
  },
);

mixin _$ContactInfoMixin {
  static Map<String, dynamic> dttCreate({
    required String email,
    String? phone,
    required Address address,
  }) {
    final values = <String, dynamic>{
      'email': email,
      'phone': phone,
      'address': address,
    };
    final processedValues = dttPreprocess(values);
    dttValidate(processedValues);
    return dttPostprocess(processedValues);
  }

  static Map<String, dynamic> dttPreprocess(Map<String, dynamic> values) {
    // Preprocessing step - modify values before validation
    values['phone'] = ContactInfo._dttpreprocess_phone(values['phone']);
    values['email'] = ContactInfo._dttpreprocess_email(values['email']);
    return values;
  }

  static void dttValidateField_email(
    dynamic value,
    Map<String, dynamic> values,
  ) {
    if (value == null) {
      throw DttValidationError('email', 'email is required');
    }
    if (value != null && !validateEmailFormat(value)) {
      throw DttValidationError('email', 'email failed custom validation');
    }
  }

  static void dttValidateField_phone(
    dynamic value,
    Map<String, dynamic> values,
  ) {
    if (value != null && value.length < 10) {
      throw DttValidationError('phone', 'phone must be at least 10 characters');
    }
    if (value != null && !ContactInfo._dttvalidate_phone(value)) {
      throw DttValidationError('phone', 'phone failed custom validation');
    }
  }

  static void dttValidateField_address(
    dynamic value,
    Map<String, dynamic> values,
  ) {}
  static void dttValidate(Map<String, dynamic> values) {
    if (values['email'] != null)
      dttValidateField_email(values['email'], values);
    if (values['phone'] != null)
      dttValidateField_phone(values['phone'], values);
    if (values['address'] != null)
      dttValidateField_address(values['address'], values);
  }

  static Map<String, dynamic> dttPostprocess(Map<String, dynamic> values) {
    // Postprocessing step - modify values after validation
    // No postprocessing methods found
    return values;
  }

  static Map<String, dynamic> dttFromMap(Map<String, dynamic> map) {
    // Process and validate map data (including nested models)
    final processedMap = <String, dynamic>{
      'email': map['email'],
      'phone': map['phone'],
      'address': _$AddressMixin.dttFromMap(
        map['address'] as Map<String, dynamic>,
      ),
    };
    // Apply preprocessing, validation, and postprocessing to the processed map
    final preprocessed = dttPreprocess(processedMap);
    dttValidate(preprocessed);
    return dttPostprocess(preprocessed);
  }

  static Map<String, dynamic> dttToMap(ContactInfo obj) {
    // Convert object instance to a map
    return {
      'email': obj.email,
      'phone': obj.phone,
      'address': _$AddressMixin.dttToMap(obj.address),
    };
  }
}

const DttModelMeta _dtt_Employee_fieldMeta = DttModelMeta(
  fields: {
    'name': DttFieldMeta(
      type: 'String',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'employeeId': DttFieldMeta(
      type: 'int',
      isFinal: true,
      isLate: false,
      subModel: null,
    ),
    'contact': DttFieldMeta(
      type: 'ContactInfo',
      isFinal: true,
      isLate: false,
      subModel: 'ContactInfo',
    ),
    'manager': DttFieldMeta(
      type: 'Employee?',
      isFinal: true,
      isLate: false,
      subModel: 'Employee',
    ),
  },
);

mixin _$EmployeeMixin {
  static Map<String, dynamic> dttCreate({
    required String name,
    required int employeeId,
    required ContactInfo contact,
    Employee? manager,
  }) {
    final values = <String, dynamic>{
      'name': name,
      'employeeId': employeeId,
      'contact': contact,
      'manager': manager,
    };
    final processedValues = dttPreprocess(values);
    dttValidate(processedValues);
    return dttPostprocess(processedValues);
  }

  static Map<String, dynamic> dttPreprocess(Map<String, dynamic> values) {
    // Preprocessing step - modify values before validation
    values['name'] = Employee._dttpreprocess_name(values['name']);
    return values;
  }

  static void dttValidateField_name(
    dynamic value,
    Map<String, dynamic> values,
  ) {
    if (value == null) {
      throw DttValidationError('name', 'name is required');
    }
    if (value != null && value.length < 2) {
      throw DttValidationError('name', 'name must be at least 2 characters');
    }
  }

  static void dttValidateField_employeeId(
    dynamic value,
    Map<String, dynamic> values,
  ) {
    if (value == null) {
      throw DttValidationError('employeeId', 'employeeId is required');
    }
    if (value != null && !Employee._dttvalidate_employeeId(value)) {
      throw DttValidationError(
        'employeeId',
        'employeeId failed custom validation',
      );
    }
  }

  static void dttValidateField_contact(
    dynamic value,
    Map<String, dynamic> values,
  ) {}
  static void dttValidateField_manager(
    dynamic value,
    Map<String, dynamic> values,
  ) {}
  static void dttValidate(Map<String, dynamic> values) {
    if (values['name'] != null) dttValidateField_name(values['name'], values);
    if (values['employeeId'] != null)
      dttValidateField_employeeId(values['employeeId'], values);
    if (values['contact'] != null)
      dttValidateField_contact(values['contact'], values);
    if (values['manager'] != null)
      dttValidateField_manager(values['manager'], values);
  }

  static Map<String, dynamic> dttPostprocess(Map<String, dynamic> values) {
    // Postprocessing step - modify values after validation
    // No postprocessing methods found
    return values;
  }

  static Map<String, dynamic> dttFromMap(Map<String, dynamic> map) {
    // Process and validate map data (including nested models)
    final processedMap = <String, dynamic>{
      'name': map['name'],
      'employeeId': map['employeeId'],
      'contact': _$ContactInfoMixin.dttFromMap(
        map['contact'] as Map<String, dynamic>,
      ),
      'manager':
          map['manager'] != null
              ? _$EmployeeMixin.dttFromMap(
                map['manager'] as Map<String, dynamic>,
              )
              : null,
    };
    // Apply preprocessing, validation, and postprocessing to the processed map
    final preprocessed = dttPreprocess(processedMap);
    dttValidate(preprocessed);
    return dttPostprocess(preprocessed);
  }

  static Map<String, dynamic> dttToMap(Employee obj) {
    // Convert object instance to a map
    return {
      'name': obj.name,
      'employeeId': obj.employeeId,
      'contact': _$ContactInfoMixin.dttToMap(obj.contact),
      'manager':
          obj.manager != null ? _$EmployeeMixin.dttToMap(obj.manager!) : null,
    };
  }
}
