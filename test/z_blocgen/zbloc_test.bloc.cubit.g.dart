// GENERATED BY DARTANTIC BLOC GENERATOR

part of 'zbloc_test.dart';

class DttBlocTestUserCubit extends Cubit<DttBlocTestUserState> {
  DttBlocTestUserCubit() : super(DttBlocTestUserState.initial()) {
  }
  void updateName(String name) {
    if (isClosed) return;
    if (state is DttBlocTestUserStateData) {
      final currentState = state as DttBlocTestUserStateData;
      try {
        // Create a map with current values and new value
        final values = <String, dynamic>{
          'name': name,
          'age': currentState.age,
          'email': currentState.email,
        };
        // Apply preprocessing and validation using the mixin methods
        final processedValues = _$TestUserMixin.dttPreprocess(values);
        _$TestUserMixin.dttValidate(processedValues);
        // Emit new state with processed values
        emit(currentState.copyWith(
          processedValues['name'],
          processedValues['age'],
          processedValues['email'],
        ));
      } on DttValidationError catch (error) {
        emit(DttBlocTestUserState.error('Invalid ' + error.field + ': ' + error.message));
      } catch (error) {
        emit(DttBlocTestUserState.error(error.toString()));
      }
    }
  }
  void updateAge(int age) {
    if (isClosed) return;
    if (state is DttBlocTestUserStateData) {
      final currentState = state as DttBlocTestUserStateData;
      try {
        // Create a map with current values and new value
        final values = <String, dynamic>{
          'name': currentState.name,
          'age': age,
          'email': currentState.email,
        };
        // Apply preprocessing and validation using the mixin methods
        final processedValues = _$TestUserMixin.dttPreprocess(values);
        _$TestUserMixin.dttValidate(processedValues);
        // Emit new state with processed values
        emit(currentState.copyWith(
          processedValues['name'],
          processedValues['age'],
          processedValues['email'],
        ));
      } on DttValidationError catch (error) {
        emit(DttBlocTestUserState.error('Invalid ' + error.field + ': ' + error.message));
      } catch (error) {
        emit(DttBlocTestUserState.error(error.toString()));
      }
    }
  }
  void updateEmail(String? email) {
    if (isClosed) return;
    if (state is DttBlocTestUserStateData) {
      final currentState = state as DttBlocTestUserStateData;
      try {
        // Create a map with current values and new value
        final values = <String, dynamic>{
          'name': currentState.name,
          'age': currentState.age,
          'email': email,
        };
        // Apply preprocessing and validation using the mixin methods
        final processedValues = _$TestUserMixin.dttPreprocess(values);
        _$TestUserMixin.dttValidate(processedValues);
        // Emit new state with processed values
        emit(currentState.copyWith(
          processedValues['name'],
          processedValues['age'],
          processedValues['email'],
        ));
      } on DttValidationError catch (error) {
        emit(DttBlocTestUserState.error('Invalid ' + error.field + ': ' + error.message));
      } catch (error) {
        emit(DttBlocTestUserState.error(error.toString()));
      }
    }
  }
  Future<void> loadData(Map<String, dynamic> data) async {
    if (isClosed) return;
    emit(DttBlocTestUserState.loading());
    try {
      // Process and validate the data using the mixin methods
      final processedData = _$TestUserMixin.dttFromMap(data);
      final stateData = DttBlocTestUserStateData.fromMap(processedData);
      if (!isClosed) {
        emit(stateData);
      }
    } on DttValidationError catch (error) {
      if (!isClosed) {
        emit(DttBlocTestUserState.error('Invalid ' + error.field + ': ' + error.message));
      }
    } catch (error) {
      if (!isClosed) {
        emit(DttBlocTestUserState.error(error.toString()));
      }
    }
  }
  bool validate() {
    if (state is! DttBlocTestUserStateData) return false;
    final currentState = state as DttBlocTestUserStateData;
    try {
      final values = currentState.toMap();
      _$TestUserMixin.dttValidate(values);
      return true;
    } catch (error) {
      return false;
    }
  }
  Future<void> saveData() async {
    if (isClosed) return;
    if (state is! DttBlocTestUserStateData) {
      emit(DttBlocTestUserState.error('No data to save'));
      return;
    }
    final currentState = state as DttBlocTestUserStateData;
    emit(DttBlocTestUserState.loading());
    try {
      // Validate before saving
      if (!validate()) {
        if (!isClosed) {
          emit(DttBlocTestUserState.error('Invalid data'));
        }
        return;
      }
      // TODO: Implement actual save logic
      await Future.delayed(Duration.zero); // Simulate async operation
      if (!isClosed) {
        emit(currentState);
      }
    } catch (error) {
      if (!isClosed) {
        emit(DttBlocTestUserState.error(error.toString()));
      }
    }
  }
  void reset() {
    if (isClosed) return;
    emit(DttBlocTestUserState.initial());
  }
}
