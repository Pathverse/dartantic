import 'dart:io';
import 'package:path/path.dart' as path;
import 'generators/state_generator.dart';
import 'generators/event_generator.dart';
import 'generators/cubit_generator.dart';
import '../../asg/asg.dart';

/// Main bloc generator class that orchestrates all generators
class BlocGenerator {
  /// Generates bloc files for all annotated classes
  static Future<void> generate({
    bool skipCleanup = false,
    List<File>? dartFiles,
  }) async {
    final projectDir = Directory.current;
    print('üìÇ Working in directory: ${projectDir.path}');

    // Clean up existing bloc files first if not skipped
    if (!skipCleanup) {
      print('üßπ Cleaning up existing bloc files...');
      await _cleanupExistingBlocFiles(projectDir.path);
    }

    // Process provided files or scan for files
    if (dartFiles != null && dartFiles.isNotEmpty) {
      print('üîÑ Processing ${dartFiles.length} files...');
      for (final file in dartFiles) {
        await _processFile(file.path);
      }
    } else {
      print('üîÑ Scanning for @dttBloc annotated classes...');
      var scannedFiles = 0;
      var foundFiles = 0;
      var generatedFiles = 0;

      // Process both lib and test directories
      for (final dirName in ['lib', 'test']) {
        final dir = Directory(path.join(projectDir.path, dirName));
        if (!await dir.exists()) continue;

        await for (final entity in dir.list(recursive: true)) {
          if (entity is File &&
              entity.path.endsWith('.dart') &&
              !entity.path.endsWith('.g.dart')) {
            scannedFiles++;
            final content = await entity.readAsString();
            if (content.contains('@dttBloc')) {
              foundFiles++;
              await _processFile(entity.path);
              generatedFiles++;
            }
          }
        }
      }

      print('üìä Summary:');
      print('  Scanned: $scannedFiles files');
      print('  Found: $foundFiles files with @dttBloc');
      print('  Generated: $generatedFiles bloc files');
    }
  }

  /// Safely deletes existing bloc files, respecting DTT-DISABLE-MODIFY
  static Future<void> _cleanupExistingBlocFiles(String projectDir) async {
    // Process both lib and test directories
    for (final dirName in ['lib', 'test']) {
      final dir = Directory(path.join(projectDir, dirName));
      if (!await dir.exists()) continue;

      await for (final entity in dir.list(recursive: true)) {
        // Only process .bloc.*.g.dart files, not .dartantic.g.dart
        if (entity is File &&
            entity.path.contains('.bloc.') &&
            entity.path.endsWith('.g.dart') &&
            !entity.path.contains('.dartantic.g.dart')) {
          try {
            final content = await entity.readAsString();
            if (!content.contains('// DTT-DISABLE-MODIFY')) {
              await entity.delete();
              print(
                'üóëÔ∏è  Deleted ${path.relative(entity.path, from: projectDir)}',
              );
            } else {
              print(
                'üîí Skipping ${path.relative(entity.path, from: projectDir)} (DTT-DISABLE-MODIFY)',
              );
            }
          } catch (e) {
            print(
              '‚ö†Ô∏è  Error processing ${path.relative(entity.path, from: projectDir)}: $e',
            );
          }
        }
      }
    }
  }

  /// Creates a new ASG instance with the standard bloc file header
  static ASG _createBlocFile(String originalFileName) {
    final asg = ASG();
    asg.addLine('// GENERATED BY DARTANTIC BLOC GENERATOR');
    asg.addLine('');
    asg.addLine("part of '$originalFileName.dart';");
    asg.addLine('');
    return asg;
  }

  /// Processes a single Dart file to generate its bloc
  static Future<void> _processFile(String filePath) async {
    print('üîç Starting to process file: ${path.relative(filePath)}');

    // Skip generator code itself
    if (filePath.contains('blocGen/generators/') ||
        filePath.contains('blocGen/main.dart')) {
      print('  ‚è© Skipping generator code');
      return;
    }

    // Skip generated files
    if (filePath.endsWith('.g.dart')) {
      print('  ‚è© Skipping generated file');
      return;
    }

    final content = await File(filePath).readAsString();
    print('  üìÑ Read file content (${content.length} bytes)');

    // Only process files with @DttBloc annotation (case insensitive)
    // Look for the exact annotation pattern
    final hasAnnotation = RegExp(
      r'@dttbloc',
      caseSensitive: false,
    ).hasMatch(content);
    final hasValidAnnotation = RegExp(
      r'@dttbloc\s*(?:\(\))?\s*(?:class|$)',
      caseSensitive: false,
    ).hasMatch(content);

    print('  üîé Annotation check:');
    print('    - Has @dttBloc: $hasAnnotation');
    print('    - Has valid format: $hasValidAnnotation');

    if (!hasAnnotation || !hasValidAnnotation) {
      print('  ‚è© Skipping - no valid @dttBloc annotation found');
      return;
    }

    // Look for metadata file with correct extension
    final metadataPath = filePath.replaceAll('.dart', '.dartantic.g.dart');
    print('  üîç Looking for metadata file: ${path.relative(metadataPath)}');

    if (!await File(metadataPath).exists()) {
      print('  ‚ö†Ô∏è  Skipping - no metadata file found');
      print(
        '     Run "dart run dartantic model" first to generate model files',
      );
      return;
    }

    print('  ‚úÖ Found metadata file');

    // Check if bloc files already exist
    final statePath = filePath.replaceAll('.dart', '.bloc.state.g.dart');
    final eventPath = filePath.replaceAll('.dart', '.bloc.event.g.dart');
    final cubitPath = filePath.replaceAll('.dart', '.bloc.cubit.g.dart');

    final allFilesExist = await Future.wait([
      File(statePath).exists(),
      File(eventPath).exists(),
      File(cubitPath).exists(),
    ]).then((exists) => exists.every((e) => e));

    if (allFilesExist) {
      print('  ‚è© Skipping - bloc files already exist');
      print('    Use --force to regenerate');
      return;
    }

    final metadata = await File(metadataPath).readAsString();
    final className = _extractClassName(metadata);
    if (className == null) {
      print('  ‚ö†Ô∏è  Skipping - could not extract class name from metadata');
      return;
    }
    print('  ‚úÖ Extracted class name: $className');

    final fields = _extractFields(metadata);
    if (fields.isEmpty) {
      print('  ‚ö†Ô∏è  Skipping - no fields found in metadata');
      return;
    }
    print('  ‚úÖ Extracted fields: ${fields.keys.join(', ')}');

    final originalFileName = path.basenameWithoutExtension(filePath);
    print('  üì¶ Generating bloc for $className in ${path.relative(filePath)}');

    try {
      // Generate state file
      final stateGenerator = StateGenerator(
        className: className,
        fields: fields,
        originalFileName: originalFileName,
      );
      final stateAsg = _createBlocFile(originalFileName);
      stateAsg.add(stateGenerator.generate());
      final stateOutputPath = filePath.replaceAll(
        '.dart',
        '.bloc.state.g.dart',
      );
      await File(stateOutputPath).writeAsString(stateAsg.source);
      print('  ‚úÖ Generated ${path.relative(stateOutputPath)}');

      // Generate event file
      final eventGenerator = EventGenerator(
        className: className,
        fields: fields,
        originalFileName: originalFileName,
      );
      final eventAsg = _createBlocFile(originalFileName);
      eventAsg.add(eventGenerator.generate());
      final eventOutputPath = filePath.replaceAll(
        '.dart',
        '.bloc.event.g.dart',
      );
      await File(eventOutputPath).writeAsString(eventAsg.source);
      print('  ‚úÖ Generated ${path.relative(eventOutputPath)}');

      // Generate cubit file
      final cubitGenerator = CubitGenerator(
        className: className,
        fields: fields,
        originalFileName: originalFileName,
      );
      final cubitAsg = _createBlocFile(originalFileName);
      cubitAsg.add(cubitGenerator.generate());
      final cubitOutputPath = filePath.replaceAll(
        '.dart',
        '.bloc.cubit.g.dart',
      );
      await File(cubitOutputPath).writeAsString(cubitAsg.source);
      print('  ‚úÖ Generated ${path.relative(cubitOutputPath)}');
    } catch (e, stackTrace) {
      print('  ‚ùå Error generating bloc for $className:');
      print('    Error: $e');
      print('    Stack trace: $stackTrace');
      rethrow;
    }
  }

  /// Extracts the class name from the metadata file
  static String? _extractClassName(String metadata) {
    // Look for the model meta constant
    final pattern = RegExp(r'const\s+DttModelMeta\s+_dtt_(\w+)_fieldMeta');
    final match = pattern.firstMatch(metadata);
    return match?.group(1);
  }

  /// Extracts fields from the metadata file
  static Map<String, String> _extractFields(String metadata) {
    final fields = <String, String>{};
    // Look for field definitions in the metadata
    final pattern = RegExp(r"'(\w+)':\s*DttFieldMeta\(\s*type:\s*'([^']+)'");
    for (final match in pattern.allMatches(metadata)) {
      final type = match.group(2)!;
      fields[match.group(1)!] = type;
    }
    return fields;
  }
}
